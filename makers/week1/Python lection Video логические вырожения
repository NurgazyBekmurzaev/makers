Логические выражения и логический тип данных
Часто в реальной жизни мы соглашаемся с каким-либо утверждением или отрицаем его. Например, если вам скажут, что сумма чисел 3 и 5 больше 7, вы согласитесь, скажете: «Да, это правда». Если же кто-то будет утверждать, что сумма трех и пяти меньше семи, то вы расцените такое утверждение как ложное.

Подобные фразы предполагают только два возможных ответа – либо "да", когда выражение оценивается как правда, истина, либо "нет", когда утверждение оценивается как ошибочное, ложное. В программировании и математике если результатом вычисления выражения может быть лишь истина или ложь, то такое выражение называется логическим.

Например, выражение 4 > 5 является логическим, так как его результатом является либо правда, либо ложь. Выражение 4 + 5 не является логическим, так как результатом его выполнения является число.

На позапрошлом уроке мы познакомились с тремя типами данных – целыми и вещественными числами, а также строками. Сегодня введем четвертый – логический тип данных (тип bool). Его также называют булевым. У этого типа всего два возможных значения: True (правда) и False (ложь)

a = True 
print(type(a))
# <class 'bool'>  
b = False 
print(type(b))
# <class 'bool'> 
Здесь переменной a было присвоено значение True, после чего с помощью встроенной в Python функции type() проверен ее тип. Интерпретатор сообщил, что это переменная класса bool. Понятия "класс" и "тип данных" в данном случае одно и то же. Переменная b также связана с булевым значением.

Note: В программировании False обычно приравнивают к нулю, а True – к единице.

Чтобы в этом убедиться, можно преобразовать булево значение к целочисленному типу:

print(int(True)) 
print(int(False))
Возможно и обратное. Можно преобразовать какое-либо значение к булевому типу:

print(bool(3.4)) # True 
print(bool(-150)) # True  
print(bool(0)) # False  
print(bool(' ')) # True  
print(bool('')) # False 
И здесь работает правило: всё, что не 0 и не пустота, является правдой.

Логические операторы.
Говоря на естественном языке (например, русском) мы обозначаем сравнения словами "равно", "больше", "меньше". В языках программирования используются специальные знаки, подобные тем, которые используются в математике:

> (больше),
< (меньше),
>= (больше или равно),
<= (меньше или равно),
== (равно),
!= (не равно).
Note: Не путайте операцию присваивания значения переменной, обозначаемую в языке Python одиночным знаком "равно", и операцию сравнения (два знака "равно").

Присваивание и сравнение – разные операции.

a = 10  
b = 5  
print(a + b > 14) # True  
print(a < 14 - b) # False  
print(a <= b + 5) # True  
print(a != b) # True  
print(a == b) # False  
c = a == b 
print(a, b, c) #(10, 5, False)  
В данном примере выражение c = a == b состоит из двух подвыражений. Сначала происходит сравнение (==) переменных a и b. После этого результат логической операции присваивается переменной c. Выражение a, b, c просто выводит значения переменных на экран.

Сложные логические выражения.
Логические выражения типа kByte >= 1023 являются простыми, так как в них выполняется только одна логическая операция.

Однако, на практике нередко возникает необходимость в более сложных выражениях. Может понадобиться получить ответа "Да" или "Нет" в зависимости от результата выполнения двух простых выражений.

Например, "на улице идет снег или дождь", "переменная news больше 12 и меньше 20".

В таких случаях используются специальные операторы, объединяющие два и более простых логических выражения. Широко используются два оператора – так называемые логические И (and) и ИЛИ (or).

Чтобы получить True при использовании оператора and, необходимо, чтобы результаты обоих простых выражений, которые связывает данный оператор, были истинными. Если хотя бы в одном случае результатом будет False, то и все сложное выражение будет ложным.

Чтобы получить True при использовании оператора or, необходимо, чтобы результат хотя бы одного простого выражения, входящего в состав сложного, был истинным. В случае оператора or сложное выражение становится ложным лишь тогда, когда ложны оба составляющие его простые выражения.

Допустим, x = 8, y = 13. Логическое выражение y < 15 and x > 8 будет выполняться следующим образом.

Сначала выполнится выражение y < 15. Его результатом будет True.
Затем выполнится выражение x > 8. Его результатом будет False.
Далее выражение сведется к True and False, что вернет False.
x = 8
y = 13 
print(y < 15 and x > 8) # False  
В случае с оператором or второе простое выражение проверяется, если первое вернуло ложь, и не проверяется, если уже первое вернуло истину. Так как для истинности всего выражения достаточно единственного True, неважно по какую сторону от or оно стоит.

print(y < 15 or x > 8) # True  
В языке Python есть еще унарный логический оператор not, т. е. отрицание. Он превращает правду в ложь, а ложь в правду.

Унарный он потому, что применяется к одному выражению, стоящему после него, а не справа и слева от него как в случае бинарных and и or.

print(not y < 15) # False  
Здесь у < 15 возвращает True. Отрицая это, мы получаем False.

a = 5 
b = 0 
print(not a) # False  
print(not b) # True  
Число 5 трактуется как истина, отрицание истины дает ложь. Ноль приравнивается к False. Отрицание False дает True.

Ветвление. Условный оператор.
Ход выполнения программы может быть линейным, то есть таким, когда выражения выполняются друг за другом, начиная с первого и заканчивая последним. Ни одна строка кода программы не пропускается.

Однако чаще в программах бывает не так. При выполнении кода, в зависимости от тех или иных условий, некоторые его участки могут быть опущены, в то время как другие – выполнены. Иными словами, в программе может присутствовать ветвление, которое реализуется условным оператором – особой конструкцией языка программирования.

Подобная нелинейность действий может быть реализована в компьютерной программе.

Например, часть кода будет выполняться лишь при определенном значении конкретной переменной.

В языках программирования используется приблизительно такая конструкция условного оператора:

if логическое_выражение: 
    выражение 1 
    выражение 2 
Перевести на человеческий язык можно так: если логическое выражение возвращает истину, то выполняются выражения внутри фигурных скобок; если логическое выражение возвращает ложь, то код внутри фигурных скобок не выполняется. С английского if переводится как если.

Конструкция if логическое_выражение называется заголовком условного оператора.

Пример использования условного оператора в языке программирования Python:

if n < 100: 
    b = n + a 
Большинство сред программирования автоматически делают отступ, как только вы поставите двоеточие и перейдете на новую строку. Однако при работе в интерактивном режиме надо делать отступы вручную.



Python считается языком с ясным синтаксисом и легко читаемым кодом. Это достигается сведением к минимуму таких вспомогательных элементов как скобок и точек с запятой. Для разделения выражений используется переход на новую строку, а для обозначения вложенных выражений – отступы от начала строки. В других языках данный стиль программирования также используется, но лишь для удобочитаемости кода человеком. В Питоне же он возведен в ранг синтаксического правила.

В примере выше логическим выражением является n < 100. Если оно возвращает истину, то выполнится строчка кода b = n + a. Если логическое выражение ложно, то выражение b = n + a не выполнится.

Данный пример вырван из контекста и сам по-себе не является рабочим. Полная версия программы могла бы выглядеть так:

b = 0 
a = 50 
n = 98 
if n < 100:
    b = n + a 
print(b) 
Последняя строчка кода print(b) уже не относится к условному оператору, что обозначено отсутствием перед ней отступа. Она не является вложенной в условный оператор, значит, не принадлежит ему.

Поскольку переменная n равна 98, а это меньше 100, то b станет равной 148. Это значение будет выведено на экран.

Если переменная n изначально была бы связана, например, со значением 101, то на экран был бы выведен 0.

При n, равной 101, логическое выражение в заголовке условного оператора вернуло бы ложь. Значит, тело не было бы выполнено, и переменная b не изменилась бы. Структуру программы можно изобразить следующим образом:



Основная ветка программы выполняется всегда, а вложенный код лишь тогда, когда в темно-зеленой строчке, обозначающей заголовок условного оператора, случается истина.

Для небольших программ иногда чертят так называемые блок-схемы, отражающие алгоритм выполнения. В языке блок-схем определенные конструкции обозначаются своими фигурами. Так блок действий обозначается прямоугольником, а логическое выражение – ромбом. Для кода выше блок схема может выглядеть так:



Условный оператор может включать не одну ветку, а две, реализуя тем самым полноценное ветвление.



В случае возврата логическим выражением False поток выполнения программы не возвращается сразу в основную ветку. На случай False существует другой вложенный код, отличный от случая True. Другими словами, встретившись с расширенной версией условного оператора, поток выполнения программы не вернется в основную ветку, не выполнив хоть какой-нибудь вложенный код.

В языках программирования разделение на две ветви достигается с помощью добавления блока else, получается так называемое if–else (если-иначе). Синтаксис выглядит примерно так:

if логическое_выражение:
    выражение 1
    выражение 2
else:
    выражение 3 
Если условие при инструкции if оказывается ложным, то выполняется блок кода при инструкции else. Ситуация, при которой бы выполнились обе ветви, невозможна. Либо код, принадлежащий if, либо код, принадлежащий еlse. Никак иначе. В заголовке else никогда не бывает логического выражения.

Пример кода с веткой else на языке программирования Python:

tovar1 = 50 
tovar2 = 32 
if tovar1 + tovar2 > 99: 
    print("99$ недостаточно") 
else: 
    print("Чек оплачен") 
Следует иметь в виду, что логическое выражение при if может выглядеть "нестандартно", т. е. не так просто, как a > b и тому подобное. Там может стоять просто одна переменная, число, слово True или False, а также сложное логическое выражение, когда два простых соединяются через логически И или ИЛИ.

a = 5 > 0 
if a: 
    print(a)
if a > 0 and a < b: 
    print(b - a) 
elif
Допустим, у нас есть следующая программа:

user_is_logged_in = True 
user_has_facebook_account = True 
user_has_github_account = True 
if user_is_logged_in: 
    print("Logged in") 
if user_has_facebook_account: 
    print("Has FB account") 
if user_has_github_account: 
    print("Has Github account")
В ней мы проверили пользователя на предмет того, вошел ли он в систему, есть ли у него аккаунт в фейсбуке, и есть ли у него гитхаб аккаунт. Так как user_is_logged_in, user_has_facebook_account, user_has_github_account хранят значение True, все функции print() в программе срабатывают. Если это ожидаемое поведение программы, то нет ничего плохого в применении нескольких if’ов.

А что, если мы хотим вывести только одно сообщение? Применяем цепочку if/elif/else:

user_is_logged_in = True 
user_has_facebook_account = False 
user_has_github_account = True 
if user_is_logged_in: 
    print("Logged in") 
elif user_has_facebook_account: 
    print("Has FB account") 
elif user_has_github_account: 
    print("Has Github account") 
else: 
    print("Not logged in and has no accounts" 
